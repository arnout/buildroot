#! /usr/bin/env python
## checkpackage
##
## This script performs various coding style checks on a package.
## It is not meant to give a final ruling, but helps to find potential
## problems.
##
## Copyright (C) 2015 Arnout Vandecappelle (Essensium/Mind)
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
##

## Note about python2.
##
## This script can currently only be run using python2 interpreter due to
## its kconfiglib dependency (which is not yet python3 friendly).

from __future__ import print_function
from __future__ import unicode_literals

import os
from argparse import ArgumentParser


try:
    import kconfiglib
except ImportError:
    message = """
Could not find the module 'kconfiglib' in the PYTHONPATH:
"""
    message += "\n".join(["  {0}".format(path) for path in sys.path])
    message += """

Make sure the Kconfiglib directory is in the PYTHONPATH, then relaunch the
script.

You can get kconfiglib from:
  https://github.com/ulfalizer/Kconfiglib


"""
    sys.stderr.write(message)
    raise

class Error:
    """ Represents a failed check.
    """

    def __init__(self, message, filename=None, line=None, severity='Error'):
        self.message = message
        self.filename = filename
        self.line = line
        self.severity = severity

    def __str__(self):
        message = '%s: ' % self.severity
        if self.filename:
            message += '%s:' % self.filename
            if self.line:
                message += '%d: ' % self.line
            else:
                message += ' '
        return message + self.message

class Buildroot:
    """ Buildroot configuration object.
    """
    root_config = "Config.in"

    def __init__(self, base_dir):
        self.base_dir = base_dir
        # The kconfiglib requires an environment variable named "srctree" to
        # load the configuration, so set it. Also set the environment
        # variables that are read in by Config.in to some value that is
        # appropriate for this script.
        os.environ.update({
            'srctree': self.base_dir,
            'BR2_VERSION_FULL': '',
            'HOSTARCH': '',
            'BR2_EXTERNAL': 'support/dummy-external',
            'BR2_DEFCONFIG': '',
            'SKIP_LEGACY': 'y',
        })
        self.config = kconfiglib.Config(os.path.join(self.base_dir,
                                                     self.root_config))

class Package:
    """ A buildroot package, i.e. something using the package infra.
    """

    def __init__(self, buildroot, packagedir):
        self.buildroot = buildroot
        self.name = os.path.basename(packagedir.rstrip('/'))
        self.directory = os.path.join(self.buildroot.base_dir, packagedir)
        self.errors = []

    def error(self, message, filename=None, line=None, severity='Error'):
        """Add a failure for this package."""
        message = '%s: %s' % (self.name, message)
        self.errors.append(Error(message, filename, line, severity))


def packageUpperName(packagename):
    """Convert PACKAGENAME to uppercase, like pkg-util's UPPERCASE macro"""
    return packagename.upper().replace('-', '_').replace('.', '_')


def checkPackage(package):
    """
    Run all checks on this package.

    This is a flat sequence of all checks that are applied to a package.
    To make navigation easier, each check should be preceded by a comment
    that identifies the rule that is checked. This comment should begin
    with CHECK.
    """

    # Convenience: direct access to the Kconfig object
    config = package.buildroot.config

    # CHECK directory exists
    if not os.path.isdir(package.directory):
        package.error("no directory %s relative to buildroot directory %s."
            % (os.path.relpath(package.directory, package.buildroot.base_dir),
                package.buildroot.base_dir))
        return # This is a fatal error

    package.files = os.listdir(package.directory)
    # CHECK pkg.mk exists
    pkg_mk_name = package.name + '.mk'
    if pkg_mk_name not in package.files:
        package.error("no %s in package directory." % pkg_mk_name)
    # CHECK hash file exists
    pkg_hash_name = package.name + '.hash'
    if pkg_hash_name not in package.files:
        package.error("no %s in package directory." % pkg_hash_name,
            severity = 'Warning')
    # CHECK Config.in exists
    if 'Config.in' not in package.files:
        package.error("no Config.in in package directory.")
        return # Probably a host package, makes no sense to continue

    # CHECK config symbol exists
    pkg_config_name = 'BR2_PACKAGE_' + packageUpperName(package.name)
    package.symbol = config.get_symbol(pkg_config_name)
    if not package.symbol or \
        not package.symbol.is_defined() or \
        not package.symbol.is_symbol():
        package.error("Kconfig symbol %s not defined. Is Config.in included?"
            % pkg_config_name)
        return # This is a fatal error

    # CHECK config symbol prompt - blind is allowed
    # prompts is a list of (prompt, conditions) tuples
    if len(package.symbol.prompts) == 0:
        pkg_config_prompt = None
    elif len(package.symbol.prompts) > 1:
        package.error("Kconfig symbol %s has multiple prompts."
            % pkg_config_name)
        pkg_config_prompt = None
    else:
        pkg_config_prompt = package.symbol.prompts[0][0]
        if pkg_config_prompt != package.name:
            package.error("Kconfig prompt is %s instead of %s." %
                (pkg_config_prompt, package.name), severity = 'Warning')

    # CHECK alphabetical ordering
    if pkg_config_prompt:
        pkg_parent = package.symbol.get_parent()
        assert pkg_parent # It simply can't be the top-level menu
        prev_symbol = None # prompt of the previous symbol
        for sibling in pkg_parent.get_items():
            # Check between package and previous symbol
            if sibling is package.symbol:
                if prev_symbol and prev_symbol.prompts[0][0] >= pkg_config_prompt:
                    package.error("Not ordered alphabetically: %s, %s" %
                        (prev_symbol.prompts[0][0], pkg_config_prompt),
                        severity = 'Warning')
                prev_symbol = package.symbol
                continue
            # Only consider symbols
            if not sibling.is_symbol():
                continue
            # Only consider symbols with prompts
            if not sibling.prompts:
                continue
            # Find the package that the sibling belongs to based on its directory
            sibling_location = sibling.get_def_locations()[0][0]
            sibling_package_name = os.path.basename(os.path.dirname(sibling_location))
            # Only consider the main package symbol, not sub-entries.
            if sibling.name != \
                    'BR2_PACKAGE_' + packageUpperName(sibling_package_name):
                continue

            if prev_symbol == package.symbol:
                prompt = sibling.prompts[0][0]
                if prompt <= pkg_config_prompt:
                    package.error("Not ordered alphabetically: %s, %s" %
                        (pkg_config_prompt, prompt), severity = 'Warning')
                break
            prev_symbol = sibling


parser = ArgumentParser(description = """\
Run some checks on a buildroot package.

This performs various coding style checks on a package for buildroot. It does
not pass final judgement, but it helps to find potential problems.

At the moment, only target packages under the package/ directory are supported.
""")

parser.add_argument("packages", metavar='package', nargs="+",
    help="""Package to check, given as a directory relative to the buildroot
        directory. E.g. package/x11r7/xfont_encodings""")

parser.add_argument("-d", "--buildroot-dir", default=".",
    help="Buildroot top-level directory (default: current directory)")


args = parser.parse_args()

buildroot = Buildroot(args.buildroot_dir)

for packagedir in args.packages:
    package = Package(buildroot, packagedir)
    checkPackage(package)
    for error in package.errors:
        print (error)
